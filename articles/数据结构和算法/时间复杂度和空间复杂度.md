
# 算法的时间复杂度和空间复杂度

## 引入

是衡量算法的执行时间和空间

通常的，算法在更大输入集合的表现更有意义

例：

```js
    // 假设：数组中有 n 个元素，下面的程序执行多少次?

    function sum(A) {
        let sum = 0

        for(let i = 0; i < A.length; i++) {
            sum += A[i]
        }
        return sum
    }

    // 分析：
    // let sum = 0 这条语句执行了 1次
    // for循环中 let i = 0 执行了 1次
    // i < A.length 执行了 n+1次
    // i++ 执行了 n次
    // sum += A[i] 执行了 n次
    // return sum 执行了 1次

    // 那么一共执行了 T = 3n + 4
    // T = 3n + 4 => O(n)
```


## 时间复杂度

时间复杂度衡量算法**执行时间**随着**输入规模**增加而增长的关系，是一种对算法的**分类**

- 一维数组求和的算法，时间复杂度是 O(n)

- 二维数组求和的算法，时间复杂度是 O(n^2)

- 三维数组求和的算法，时间复杂度是 O(n^3)

- 四维数组求和的算法，时间复杂度是 O(n^4)

- 五维数组求和的算法，时间复杂度是 O(n^5)


## 空间复杂度

空间复杂度是指算法用了多少额外的空间

例：


```js
    function sum(A) { // A 这里创建了 1个空间
        let sum = 0  // sum 创建了 1个空间
        for(let i = 0; i < A.length; i++) { // i 创建了 1个空间
            sum += A[i]
        }
        return sum
    }

    // 一共 S = 3 => S = C => O(1)
```


```
插入排序的时间复杂度是：最好的情况 O(n^2) 最坏的情况是 o(n)
插入排序的空间复杂度是：O(1)
反转数组的复杂度是：时间O(n) 空间O(1)
二分查找：时间O(logn) 空间O(1)

```

### 二分查找递归写法的复杂度

时间复杂度：O(lgn) 空间复杂度：O(lgn)

代码实现：

```js
    function bsearch(A, x, l=0, r=A.length-1) {
        const guess = Math.floor( (l + r)/2 )
        if(l > r) return -1

        if(A[guess] === x) return guess

        return A[guess] < x ?
            bsearch(A, x, l=guess+1, r) :
            bsearch(A, x, l, r=guess-1)
    }
```


### 复杂度求和

复杂度是度量指标随着输入规模增长关系的一种**分类**。
描述的是随着输入规模增加算法中**最大的影响因子**

```
    O(1) + O(1) = O(1)

    O(n) + O(n) = O(n)
    
    O(lgn) + O(lgn) = O(lgn)

    O(lgn) + O(n) = O(n)
    
    O(n) + O(1) = O(n)

    O(n^2) + O(n) = O(n^2)

```


### GIG-O

数学上**O(n)**是指随着规模增长，算法的执行时间会在 T=cn内波动，c 是大于0的**任意常数**

BIG-O是一种渐进标志

```
    渐近上界 O(最坏的情况)
    渐近下(最好的情况)
```

## 如何降低复杂度

```
    分治策略：O(n^2) -> O(nlgn)

    散列： O(n) -> O(1)
           O(n) -> O(k)

    二叉树： O(n) -> O(lgn)    

    链表：O(n) -> O(1)

    动态规划：O(n!) -> O(n^2)
             O(2^n) -> O(n^2)   

```